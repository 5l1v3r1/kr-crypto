#include <stdint.h>
#include <stdio.h>
#include <string.h>

// S-box
const uint8_t S[] = {
    0xA6, 0x6B, 0x72, 0xEA, 0x0F, 0xEB, 0x3E, 0x28,
    0xF5, 0xAD, 0x73, 0x8B, 0x97, 0x9F, 0xBB, 0x2F,
    0x4F, 0x92, 0xB0, 0x5D, 0x42, 0xC3, 0xB3, 0x77,
    0xC4, 0x8F, 0xD4, 0x6E, 0x9C, 0x90, 0xFA, 0xC5,
    0x3A, 0xE4, 0xCE, 0x45, 0x8A, 0xE2, 0x51, 0x7D,
    0x20, 0x53, 0x6C, 0x52, 0x8C, 0xEC, 0x05, 0xF7,
    0x2D, 0x83, 0xF4, 0x44, 0x0D, 0x31, 0x78, 0xB9,
    0xD2, 0x38, 0x85, 0x49, 0x1E, 0x1A, 0x60, 0x1F,
    0xD0, 0xB2, 0x22, 0x7E, 0x76, 0x47, 0x61, 0xB4,
    0xFE, 0xF3, 0x2E, 0x88, 0x06, 0xD6, 0x5E, 0xDA,
    0xAB, 0x68, 0x4D, 0xA5, 0x33, 0xE5, 0x00, 0xDC,
    0xF2, 0x89, 0x32, 0x7C, 0xAE, 0x3D, 0x04, 0x79,
    0xB1, 0x12, 0xA3, 0x25, 0x02, 0x21, 0x2C, 0x94,
    0xBE, 0x34, 0xC6, 0xD1, 0x54, 0x69, 0xD7, 0xDE,
    0x01, 0xFD, 0x9B, 0x37, 0xAF, 0xE7, 0x36, 0x10,
    0x98, 0x2B, 0xDF, 0xFF, 0x64, 0x3B, 0xD5, 0x26,
    0x4A, 0x63, 0xC1, 0xA2, 0xE0, 0xD9, 0x58, 0x75,
    0x48, 0x86, 0x2A, 0x50, 0x29, 0xC8, 0xCD, 0x15,
    0x59, 0x6A, 0x43, 0xF1, 0xB7, 0x82, 0xB5, 0x4C,
    0xA8, 0xB8, 0x46, 0xF9, 0x57, 0x55, 0x11, 0xD8,
    0xBC, 0xED, 0x74, 0x81, 0x71, 0x9E, 0xA0, 0x1C,
    0x8D, 0xBF, 0x6F, 0xDB, 0xA4, 0x35, 0x1D, 0x5C,
    0x0E, 0x09, 0xF8, 0x99, 0xC0, 0xAA, 0x13, 0xD3,
    0xB6, 0xDD, 0x91, 0x7F, 0xE3, 0x03, 0x19, 0xE8,
    0xC7, 0x0A, 0xCF, 0x41, 0xAC, 0xC9, 0xA1, 0x5A,
    0xEF, 0xBA, 0xE6, 0x9A, 0xFC, 0x67, 0xC2, 0x18,
    0x96, 0xCB, 0xCC, 0xEE, 0x66, 0x80, 0x07, 0x3C,
    0x0C, 0x16, 0x39, 0x3F, 0x0B, 0x6D, 0x56, 0x08,
    0xE9, 0xF6, 0x5F, 0x7A, 0x93, 0x70, 0xCA, 0x8E,
    0xFB, 0x7B, 0x24, 0xA9, 0x87, 0xF0, 0x84, 0x4B,
    0x95, 0x65, 0xBD, 0x17, 0x1B, 0x5B, 0x14, 0x4E,
    0x23, 0x30, 0x9D, 0x62, 0x40, 0x27, 0xA7, 0xE1
};

const uint8_t invS[] = {
    0x56, 0x70, 0x64, 0xBD, 0x5E, 0x2E, 0x4C, 0xD6,
    0xDF, 0xB1, 0xC1, 0xDC, 0xD8, 0x34, 0xB0, 0x04,
    0x77, 0x9E, 0x61, 0xB6, 0xF6, 0x8F, 0xD9, 0xF3,
    0xCF, 0xBE, 0x3D, 0xF4, 0xA7, 0xAE, 0x3C, 0x3F,
    0x28, 0x65, 0x42, 0xF8, 0xEA, 0x63, 0x7F, 0xFD,
    0x07, 0x8C, 0x8A, 0x79, 0x66, 0x30, 0x4A, 0x0F,
    0xF9, 0x35, 0x5A, 0x54, 0x69, 0xAD, 0x76, 0x73,
    0x39, 0xDA, 0x20, 0x7D, 0xD7, 0x5D, 0x06, 0xDB,
    0xFC, 0xC3, 0x14, 0x92, 0x33, 0x23, 0x9A, 0x45,
    0x88, 0x3B, 0x80, 0xEF, 0x97, 0x52, 0xF7, 0x10,
    0x8B, 0x26, 0x2B, 0x29, 0x6C, 0x9D, 0xDE, 0x9C,
    0x86, 0x90, 0xC7, 0xF5, 0xAF, 0x13, 0x4E, 0xE2,
    0x3E, 0x46, 0xFB, 0x81, 0x7C, 0xF1, 0xD4, 0xCD,
    0x51, 0x6D, 0x91, 0x01, 0x2A, 0xDD, 0x1B, 0xAA,
    0xE5, 0xA4, 0x02, 0x0A, 0xA2, 0x87, 0x44, 0x17,
    0x36, 0x5F, 0xE3, 0xE9, 0x5B, 0x27, 0x43, 0xBB,
    0xD5, 0xA3, 0x95, 0x31, 0xEE, 0x3A, 0x89, 0xEC,
    0x4B, 0x59, 0x24, 0x0B, 0x2C, 0xA8, 0xE7, 0x19,
    0x1D, 0xBA, 0x11, 0xE4, 0x67, 0xF0, 0xD0, 0x0C,
    0x78, 0xB3, 0xCB, 0x72, 0x1C, 0xFA, 0xA5, 0x0D,
    0xA6, 0xC6, 0x83, 0x62, 0xAC, 0x53, 0x00, 0xFE,
    0x98, 0xEB, 0xB5, 0x50, 0xC4, 0x09, 0x5C, 0x74,
    0x12, 0x60, 0x41, 0x16, 0x47, 0x96, 0xB8, 0x94,
    0x99, 0x37, 0xC9, 0x0E, 0xA0, 0xF2, 0x68, 0xA9,
    0xB4, 0x82, 0xCE, 0x15, 0x18, 0x1F, 0x6A, 0xC0,
    0x8D, 0xC5, 0xE6, 0xD1, 0xD2, 0x8E, 0x22, 0xC2,
    0x40, 0x6B, 0x38, 0xB7, 0x1A, 0x7E, 0x4D, 0x6E,
    0x9F, 0x85, 0x4F, 0xAB, 0x57, 0xB9, 0x6F, 0x7A,
    0x84, 0xFF, 0x25, 0xBC, 0x21, 0x55, 0xCA, 0x75,
    0xBF, 0xE0, 0x03, 0x05, 0x2D, 0xA1, 0xD3, 0xC8,
    0xED, 0x93, 0x58, 0x49, 0x32, 0x08, 0xE1, 0x2F,
    0xB2, 0x9B, 0x1E, 0xE8, 0xCC, 0x71, 0x48, 0x7B
};

// MDS matrix for P-box (1)
const uint8_t P1[] = {
    3, 1, 1, 2, 0, 0, 0, 0,
    2, 3, 1, 1, 0, 0, 0, 0,
    1, 2, 3, 1, 0, 0, 0, 0,
    1, 1, 2, 3, 0, 0, 0, 0,
    0, 0, 0, 0, 3, 1, 1, 2,
    0, 0, 0, 0, 2, 3, 1, 1,
    0, 0, 0, 0, 1, 2, 3, 1,
    0, 0, 0, 0, 1, 1, 2, 3
};

// Inverse matrix for P-box (1)
const uint8_t invP1[] = {
    9, 14, 11, 13, 0, 0, 0, 0,
    13, 9, 14, 11, 0, 0, 0, 0,
    11, 13, 9, 14, 0, 0, 0, 0,
    14, 11, 13, 9, 0, 0, 0, 0,
    0, 0, 0, 0, 9, 14, 11, 13,
    0, 0, 0, 0, 13, 9, 14, 11,
    0, 0, 0, 0, 11, 13, 9, 14,
    0, 0, 0, 0, 14, 11, 13, 9
};

// MDS matrix for P-box (2)
const uint8_t P2[] = {
    3, 7, 5, 2, 5, 4, 2, 3,
    3, 3, 7, 5, 2, 5, 4, 2,
    2, 3, 3, 7, 5, 2, 5, 4,
    4, 2, 3, 3, 7, 5, 2, 5,
    5, 4, 2, 3, 3, 7, 5, 2,
    2, 5, 4, 2, 3, 3, 7, 5,
    5, 2, 5, 4, 2, 3, 3, 7,
    7, 5, 2, 5, 4, 2, 3, 3
};

// Inverse matrix for P-box (2)
const uint8_t invP2[] = {
    0x45, 0x72, 0x13, 0xDF, 0x54, 0x53, 0x50, 0x5A,
    0x5A, 0x45, 0x72, 0x13, 0xDF, 0x54, 0x53, 0x50,
    0x50, 0x5A, 0x45, 0x72, 0x13, 0xDF, 0x54, 0x53,
    0x53, 0x50, 0x5A, 0x45, 0x72, 0x13, 0xDF, 0x54,
    0x54, 0x53, 0x50, 0x5A, 0x45, 0x72, 0x13, 0xDF,
    0xDF, 0x54, 0x53, 0x50, 0x5A, 0x45, 0x72, 0x13,
    0x13, 0xDF, 0x54, 0x53, 0x50, 0x5A, 0x45, 0x72,
    0x72, 0x13, 0xDF, 0x54, 0x53, 0x50, 0x5A, 0x45
};

// Multiplication in Rijndael's GF(2^8) mod x^8 + x^4 + x^ 3 + x + 1
uint8_t mult2(uint8_t a)
{
    if (a & 0x80)
        return (a << 1) ^ 0x1B;
    else
        return a << 1;
}

uint8_t mult(uint8_t a, uint8_t b)
{
    uint8_t x = 0;
    for (int i = 7; i >= 0; --i)
    {
        x = mult2(x);
        if (b & (1 << i))
            x ^= a;
    }
    return x;
}

void multMatrix(uint8_t *vOut, uint8_t *vIn, const uint8_t *M)
{
    for (int i = 0; i < 8; ++i)
    {
        vOut[i] = 0;
        for (int j = 0; j < 8; ++j)
        {
            vOut[i] ^= mult(vIn[j], M[i * 8 + j]);
        }
    }
}

void NesRound(uint8_t *state, const uint8_t *RK, const uint8_t *S, const uint8_t *P)
{
    // Substitution
    for (int i = 0; i < 32; ++i)
    {
        state[i] = S[state[i]];
    }

    // Transposition
    for (int j = 0; j < 4; ++j)
    {
        for (int i = 0; i < j; ++i)
        {
            uint8_t t;

            t = state[j * 8 + i];
            state[j * 8 + i] = state[i * 8 + j];
            state[i * 8 + j] = t;

            t = state[j * 8 + 4 + i];
            state[j * 8 + 4 + i] = state[i * 8 + 4 + j];
            state[i * 8 + 4 + j] = t;
        }
    }

    if (P)
    {
        // Permutation
        for (int j = 0; j < 4; ++j)
        {
            uint8_t *row = &state[j * 8];
            uint8_t tmp[8];

            multMatrix(tmp, row, P);

            for (int i = 0; i < 8; ++i)
                row[i] = tmp[i];
        }
    }

    // Add round key
    for (int i = 0; i < 32; ++i)
    {
        state[i] = state[i] ^ RK[i];
    }
}

void NesProcess(uint8_t *data, const uint8_t *EK, const uint8_t *S, const uint8_t *P1, const uint8_t *P2)
{
    uint8_t state[32];

    // Add round-0 key
    for (int i = 0; i < 32; ++i)
    {
        state[i] = data[i] ^ EK[i];
    }

    // Round 1 - 11
    for (int n = 1; n < 12; ++n)
    {

        if ((n % 2) == 1)
            // odd round (FO)
            NesRound(state, &EK[n * 32], S, P1);
        else
            // even round (FE)
            NesRound(state, &EK[n * 32], S, P2);
    }

    // Round 12 (final round)
    NesRound(state, &EK[12 * 32], S, NULL);

    for (int i = 0; i < 32; ++i)
    {
        data[i] = state[i];
    }
}

void NesEncrypt(uint8_t *data, const uint8_t *EK)
{
    NesProcess(data, EK, S, P1, P2);
}

void NesDecrypt(uint8_t *data, const uint8_t *EK)
{
    NesProcess(data, EK, invS, invP1, invP2);
}

void NesKeySchedule(uint8_t *EK, const uint8_t *k_)
{
    uint8_t k[32];
    uint8_t tmp[8] = {0}, tmp2[8];

    memcpy(k, k_, sizeof(k));

    for (int n = 0; n < 13; ++n)
    {
        int j, j1, j2, j3, j4;

        j = n % 8;
        j1 = (j + 1) % 8, j2 = (j + 2) % 8, j3 = (j + 3) % 8, j4 = (j + 4) % 8;

        // Substitution
        for (int i = 0; i < 4; ++i)
        {
            tmp[i] = invS[k[i + j*4]];
        }

        // Permutation
        multMatrix(tmp2, tmp, invP1);

        // Add "round key"
        for (int i = 0; i < 4; ++i)
        {
            k[i + j*4] = tmp2[i] ^ k[i + j1*4];
        }

        // Save expanded keys
        for (int i = 0; i < 4; ++i)
        {
            EK[n * 32 + i + 0] = k[i + j*4];
            EK[n * 32 + i + 4] = k[i + j*4] ^ k[i + j2*4];
            EK[n * 32 + i + 8] = k[i + j*4] ^ k[i + j3*4];
            EK[n * 32 + i + 12] = k[i + j*4] ^ k[i + j4*4];
        }

        j = (n + 4) % 8;
        j1 = (j + 1) % 8, j2 = (j + 2) % 8, j3 = (j + 3) % 8, j4 = (j + 4) % 8;

        // Substitution
        for (int i = 0; i < 4; ++i)
        {
            tmp[i] = invS[k[i + j*4]];
        }

        // Permutation
        multMatrix(tmp2, tmp, invP1);

        // Add "round key"
        for (int i = 0; i < 4; ++i)
        {
            k[i + j*4] = tmp2[i] ^ k[i + j1*4];
        }

        // Save expanded keys
        for (int i = 0; i < 4; ++i)
        {
            EK[n * 32 + 16 + i + 0] = k[i + j*4];
            EK[n * 32 + 16 + i + 4] = k[i + j*4] ^ k[i + j2*4];
            EK[n * 32 + 16 + i + 8] = k[i + j*4] ^ k[i + j3*4];
            EK[n * 32 + 16 + i + 12] = k[i + j*4] ^ k[i + j4*4];
        }
    }
}

void NesDeKeySchedule(uint8_t *DEK, uint8_t *EK)
{
    for (int n = 0; n < 13; ++n)
    {
        uint8_t *eRow = &EK[(12 - n) * 32];
        uint8_t *dRow = &DEK[n * 32];

        if (n == 0 || n == 12)
        {
            // first and last round keys don't need transformed
            for (int i = 0; i < 32; i++)
                dRow[i] = eRow[i];
        }
        else if ((n % 2) == 1)
        {
            for (int j = 0; j < 4; j++)
                multMatrix(&dRow[j * 8], &eRow[j * 8], invP1);
        }
        else
        {
            for (int j = 0; j < 4; j++)
                multMatrix(&dRow[j * 8], &eRow[j * 8], invP2);
        }
    }
}

int main(int argc, char *argv[])
{
    uint8_t k[32];
    uint8_t data[32];
    uint8_t EK[448], DEK[448];

    for (int i = 0; i < 32; i++)
        k[i] = i;
    for (int i = 0; i < 32; i++)
        data[i] = i;

    NesKeySchedule(EK, k);
    NesEncrypt(data, EK);

    for (int i = 0; i < 32; i++)
        printf("%02X ", data[i]);
    printf("\n");

    NesDeKeySchedule(DEK, EK);
    NesDecrypt(data, DEK);

    for (int i = 0; i < 32; i++)
        printf("%02X ", data[i]);
    printf("\n");

    return 0;
}
